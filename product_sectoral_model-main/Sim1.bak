	
Label Root
{
	Son: SECTOR
	Label SECTOR
	{
		Son: FIRM
		Label FIRM
		{
			Son: CAPITAL
			Label CAPITAL
			{
				Param: C_production
				Param: C_productive_capacity
				Param: C_productivity
				Param: C_date_birth
				Param: C_depreciation_period
				Param: C_to_replace

			}

			Son: PRODUCT
			Label PRODUCT
			{
				Param: P_id
				Var: P_Aftertax_Revenue
				Var: P_Competitiveness
				Var: P_Desired_Markup
				Var: P_Effective_Market_Share
				Var: P_Effective_Markup
				Var: P_Effective_Orders
				Var: P_Effective_Production
				Var: P_Expected_Sales
				Var: P_Imitation_Quality
				Var: P_Indirect_Tax
				Var: P_Innovation_Quality
				Var: P_Inventories
				Var: P_Market_Share
				Var: P_Planned_Production
				Var: P_Price
				Var: P_Quality
				Var: P_Quality_RND_Expenses
				Var: P_Revenue
				Var: P_Sales
				Var: P_Variable_Cost
				Param: P_desired_inventories_proportion
				Param: P_indirect_tax_rate
				Param: P_input_tech_coefficient
				Param: P_quality_innovation_share
				Param: P_quality_rnd_proportion
				Param: P_desired_market_share
				Var: P_Profits
				Var: P_Profit_Rate
				Var: P_Avg_Market_Share
				Var: P_Desired_Market_Share
				Var: P_Innovation_RND_Share
				Var: P_Product_Imitation_RND_Expenses
				Var: P_Product_Innovation_RND_Expenses
				Var: P_Product_RND_Share
				Var: P_Quality_RND_Share
				Param: P_product_rnd_share_max
				Param: P_quality_rnd_share_max
				Param: P_innovation_imitation_adjustment
				Param: P_markup_period
				Param: P_product_adjustment
				Param: P_quality_adjustment
				Var: P_Total_Variable_Cost
				Param: P_innovation_adjustment
				Param: P_innovation_floor
				Param: P_innovation_zone_parameter
				Param: P_resource_share_required
				Param: P_rnd_shrink

			}

			Var: F_Wage
			Var: F_Avg_Productivity
			Var: F_Capacity_Utilization
			Var: F_Debt_Payment
			Var: F_Distributed_Profits
			Var: F_Effective_Production
			Var: F_Financial_Obligations
			Var: F_Frontier_Productivity
			Var: F_Imitation_Productivity
			Var: F_Innovation_Productivity
			Var: F_Interest_Payment
			Var: F_Net_Profits
			Var: F_Productivity_RND_Expenses
			Var: F_Profit_Rate
			Var: F_Retained_Profits
			Param: F_debt_repayment
			Param: F_expectations
			Param: F_markup_adjustment
			Param: F_markup_passthrough_tax
			Param: F_productivity_innovation_share
			Param: F_productivity_rnd_proportion
			Param: F_profits_distribution_rate
			Param: F_strategic_price_weight
			Param: F_desired_degree_capacity_utilization
			Var: F_Capital
			Var: F_Demand_Capital_Goods_Expansion
			Var: F_Demand_Capital_Goods_Replacement
			Var: F_Desired_Expansion_Investment_Expenses
			Var: F_Desired_Replacement_Investment_Expenses
			Var: F_Expected_Sales
			Var: F_Productive_Capacity
			Var: F_Productive_Capacity_Depreciation
			Param: F_product_innovation_share
			Var: F_Innovation_Product
			Param: F_id
			Var: F_Imitation_Product
			Var: F_Investment_Expenses
			Var: F_Product_Imitation_RND_Expenses
			Var: F_Product_Innovation_RND_Expenses
			Param: F_date_birth
			Var: F_Revenue
			Var: F_Debt_Rate
			Var: F_Stock_Deposits
			Var: F_Stock_Debt
			Param: F_debt_interest_rate
			Param: F_deposit_interest_rate
			Var: F_Available_Funds

		}

		Son: MARKET
		Label MARKET
		{
			Param: M_id
			Param: M_elasticity_price
			Param: M_elasticity_quality
			Var: M_Avg_Competitiveness
			Var: M_Avg_Price
			Var: M_Effective_Orders
			Var: M_Sales
			Param: M_real_demand_growth
			Param: M_date_birth
			Var: M_Avg_Sales
			Var: M_Number_Potential_Entrants
			Param: M_entry_barrier
			Param: M_max_demand
			Param: M_switch_entry
			Param: M_max_entry_number
			Var: M_Market_Share_Adjustment
			Var: M_Avg_Market_Share
			Var: M_Firm_Entry
			Var: M_Firm_Market_Exit
			Var: M_Market_Normalized_HHI
			Var: M_Market_Firm_Number
			Var: M_Market_Avg_Productive_Capacity

		}

		Param: S_initial_productivity
		Param: S_initial_quality
		Param: S_std_dev_productivity
		Param: S_std_dev_quality
		Param: S_tech_opportunity_productivity
		Param: S_tech_opportunity_quality
		Param: S_wage_passthrough_employment
		Param: S_wage_passthrough_inflation
		Param: S_wage_passthrough_productivity
		Param: S_input_price_growth
		Param: S_capital_price_growth
		Param: S_cpi_growth
		Param: S_competitiveness_adjustment
		Var: S_Capital_Price
		Var: S_CPI
		Var: S_Input_Price
		Var: S_Employment
		Param: S_capital_output_ratio
		Param: S_depreciation_period
		Param: S_payback_period
		Param: S_product_difficulty
		Param: S_product_patent
		Param: S_demand_scale
		Param: S_logistic_growth
		Param: S_demand_duration
		Var: S_Firm_Exit
		Param: S_switch_exit
		Param: S_max_leverage_ratio
		Param: S_decline_delay_factor
		Param: S_min_market_share
		Var: S_Market_Exit
		Var: S_Firm_Number
		Var: S_Sector_Normalized_HHI
		Var: S_Avg_Debt_Rate
		Param: S_logistic_degrowth
		Var: S_Avg_Profit_Rate

	}


}


DATA

Object: Root C	1

Object: SECTOR C	1
Param: S_initial_productivity 0 n + n n	1
Param: S_initial_quality 0 n + n n	1
Param: S_std_dev_productivity 0 n + n n	0.005
Param: S_std_dev_quality 0 n + n n	0.005
Param: S_tech_opportunity_productivity 0 n + n n	0.02
Param: S_tech_opportunity_quality 0 n + n n	0.02
Param: S_wage_passthrough_employment 0 n + n n	0
Param: S_wage_passthrough_inflation 0 n + n n	0
Param: S_wage_passthrough_productivity 0 n + n n	0
Param: S_input_price_growth 0 n + n n	0
Param: S_capital_price_growth 0 n + n n	0
Param: S_cpi_growth 0 n + n n	0
Param: S_competitiveness_adjustment 0 n + n n	0.5
Var: S_Capital_Price 1 n + n n	2
Var: S_CPI 2 n + n n	1	1
Var: S_Input_Price 1 n + n n	1
Var: S_Employment 2 n + n n	100	100
Param: S_capital_output_ratio 0 n + n n	0.5
Param: S_depreciation_period 0 n + n n	50
Param: S_payback_period 0 n + n n	5
Param: S_product_difficulty 0 n + n n	0.75
Param: S_product_patent 0 n + n n	0
Param: S_demand_scale 0 n + n n	200
Param: S_logistic_growth 0 n + n n	0.02
Param: S_demand_duration 0 n + n n	150
Var: S_Firm_Exit 0 n + n n
Param: S_switch_exit 0 n + n n	1
Param: S_max_leverage_ratio 0 n + n n	2.5
Param: S_decline_delay_factor 0 n + n n	2.5
Param: S_min_market_share 0 n + n n	0.001
Var: S_Market_Exit 0 n + n n
Var: S_Firm_Number 0 s + n n
Var: S_Sector_Normalized_HHI 0 s + n n
Var: S_Avg_Debt_Rate 0 s + n n
Param: S_logistic_degrowth 0 n + n n	0.01
Var: S_Avg_Profit_Rate 0 n + n n

Object: FIRM C	1
Var: F_Wage 1 n + n n	0.5
Var: F_Avg_Productivity 2 n + n n	1	1
Var: F_Capacity_Utilization 0 n + n n
Var: F_Debt_Payment 0 n + n n
Var: F_Distributed_Profits 0 n + n n
Var: F_Effective_Production 0 n + n n
Var: F_Financial_Obligations 0 n + n n
Var: F_Frontier_Productivity 1 n + n n	1
Var: F_Imitation_Productivity 0 n + n n
Var: F_Innovation_Productivity 0 n + n n
Var: F_Interest_Payment 0 n + n n
Var: F_Net_Profits 0 n + n n
Var: F_Productivity_RND_Expenses 0 n + n n
Var: F_Profit_Rate 0 n + n n
Var: F_Retained_Profits 1 n + n n	0
Param: F_debt_repayment 0 n + n n	0.025
Param: F_expectations 0 n + n n	0.3
Param: F_markup_adjustment 0 n + n n	0.05
Param: F_markup_passthrough_tax 0 n + n n	0
Param: F_productivity_innovation_share 0 n + n n	0.5
Param: F_productivity_rnd_proportion 0 n + n n	0.05
Param: F_profits_distribution_rate 0 n + n n	0.9
Param: F_strategic_price_weight 0 n + n n	0.5
Param: F_desired_degree_capacity_utilization 0 n + n n	0.8
Var: F_Capital 1 n + n n	100
Var: F_Demand_Capital_Goods_Expansion 1 n + n n	0
Var: F_Demand_Capital_Goods_Replacement 1 n + n n	0
Var: F_Desired_Expansion_Investment_Expenses 0 n + n n
Var: F_Desired_Replacement_Investment_Expenses 0 n + n n
Var: F_Expected_Sales 0 n + n n
Var: F_Productive_Capacity 0 n + n n
Var: F_Productive_Capacity_Depreciation 0 n + n n
Param: F_product_innovation_share 0 n + n n	0.5
Var: F_Innovation_Product 0 n + n n
Param: F_id 0 n + n n	1
Var: F_Imitation_Product 0 s + n n
Var: F_Investment_Expenses 0 n + n n
Var: F_Product_Imitation_RND_Expenses 0 n + n n
Var: F_Product_Innovation_RND_Expenses 0 n + n n
Param: F_date_birth 0 n + n n	0
Var: F_Revenue 0 n + n n
Var: F_Debt_Rate 1 s + n n	0
Var: F_Stock_Deposits 1 s + n n	0
Var: F_Stock_Debt 1 s + n n	0
Param: F_debt_interest_rate 0 n + n n	0.015
Param: F_deposit_interest_rate 0 n + n n	0.01
Var: F_Available_Funds 0 n + n n

Object: CAPITAL C	50
Param: C_production 0 n + n n	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
Param: C_productive_capacity 0 n + n n	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2	2
Param: C_productivity 0 n + n n	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1
Param: C_date_birth 0 n + n n	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
Param: C_depreciation_period 0 n + n n	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50	50
Param: C_to_replace 0 n + n n	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0

Object: PRODUCT C	1
Param: P_id 0 s + n n	1
Var: P_Aftertax_Revenue 0 n + n n
Var: P_Competitiveness 1 n + n n	1
Var: P_Desired_Markup 1 n + n n	1.5
Var: P_Effective_Market_Share 0 s + n n
Var: P_Effective_Markup 0 n + n n
Var: P_Effective_Orders 2 n + n n	100	100
Var: P_Effective_Production 0 n + n n
Var: P_Expected_Sales 1 n + n n	0
Var: P_Imitation_Quality 0 n + n n
Var: P_Indirect_Tax 0 n + n n
Var: P_Innovation_Quality 0 n + n n
Var: P_Inventories 1 n + n n	10
Var: P_Market_Share 4 s + n n	1	1	1	1
Var: P_Planned_Production 0 n + n n
Var: P_Price 1 n + n n	1.2
Var: P_Quality 1 n + n n	1
Var: P_Quality_RND_Expenses 0 n + n n
Var: P_Revenue 0 n + n n
Var: P_Sales 0 n + n n
Var: P_Variable_Cost 0 n + n n
Param: P_desired_inventories_proportion 0 n + n n	0.1
Param: P_indirect_tax_rate 0 n + n n	0.1
Param: P_input_tech_coefficient 0 n + n n	0.3
Param: P_quality_innovation_share 0 n + n n	0.5
Param: P_quality_rnd_proportion 0 n + n n	0.05
Param: P_desired_market_share 0 n + n n	1
Var: P_Profits 0 n + n n
Var: P_Profit_Rate 1 n + n n	0
Var: P_Avg_Market_Share 1 n + n n	1
Var: P_Desired_Market_Share 1 n + n n	1
Var: P_Innovation_RND_Share 1 s + n n	0.5
Var: P_Product_Imitation_RND_Expenses 0 s + n n
Var: P_Product_Innovation_RND_Expenses 0 s + n n
Var: P_Product_RND_Share 1 s + n n	0.1
Var: P_Quality_RND_Share 1 s + n n	0.1
Param: P_product_rnd_share_max 0 n + n n	0.3
Param: P_quality_rnd_share_max 0 n + n n	0.3
Param: P_innovation_imitation_adjustment 0 n + n n	0.02
Param: P_markup_period 0 n + n n	4
Param: P_product_adjustment 0 n + n n	0.03
Param: P_quality_adjustment 0 n + n n	0.03
Var: P_Total_Variable_Cost 0 n + n n
Param: P_innovation_adjustment 0 n + n n	0.02
Param: P_innovation_floor 0 n + n n	0.01
Param: P_innovation_zone_parameter 0 n + n n	0.5
Param: P_resource_share_required 0 n + n n	0.1
Param: P_rnd_shrink 0 n + n n	0.5

Object: MARKET C	1
Param: M_id 0 s + n n	1
Param: M_elasticity_price 0 n + n n	1
Param: M_elasticity_quality 0 n + n n	1
Var: M_Avg_Competitiveness 1 s + n n	1
Var: M_Avg_Price 1 s + n n	1.2
Var: M_Effective_Orders 1 s + n n	100
Var: M_Sales 0 n + n n
Param: M_real_demand_growth 0 n + n n	0.05
Param: M_date_birth 0 n + n n	0
Var: M_Avg_Sales 1 n + n n	100
Var: M_Number_Potential_Entrants 0 s + n n
Param: M_entry_barrier 0 n + n n	0.5
Param: M_max_demand 0 n + n n	500
Param: M_switch_entry 0 n + n n	1
Param: M_max_entry_number 0 n + n n	3
Var: M_Market_Share_Adjustment 0 s + n n
Var: M_Avg_Market_Share 1 n + n n	1
Var: M_Firm_Entry 0 s + n n
Var: M_Firm_Market_Exit 0 n + n n
Var: M_Market_Normalized_HHI 0 s + n n
Var: M_Market_Firm_Number 0 s + n n
Var: M_Market_Avg_Productive_Capacity 0 n + n n

SIM_NUM 1
SEED 1
MAX_STEP 500
EQUATION fun_product_sectoral_model.cpp
MODELREPORT report_Sim1.html

DESCRIPTION

Object_Root

END_DESCRIPTION

Object_SECTOR

END_DESCRIPTION

Parameter_S_initial_productivity

_INIT_
All 1 instances equal to 1
END_DESCRIPTION

Parameter_S_initial_quality

_INIT_
All 1 instances equal to 1
END_DESCRIPTION

Parameter_S_std_dev_productivity

_INIT_
All 1 instances equal to 0.005
END_DESCRIPTION

Parameter_S_std_dev_quality

_INIT_
All 1 instances equal to 0.005
END_DESCRIPTION

Parameter_S_tech_opportunity_productivity

_INIT_
All 1 instances equal to 0.02
END_DESCRIPTION

Parameter_S_tech_opportunity_quality

_INIT_
All 1 instances equal to 0.02
END_DESCRIPTION

Parameter_S_wage_passthrough_employment

_INIT_
All 1 instances equal to 0.9
END_DESCRIPTION

Parameter_S_wage_passthrough_inflation

_INIT_
All 1 instances equal to 1
END_DESCRIPTION

Parameter_S_wage_passthrough_productivity

_INIT_
All 1 instances equal to 0.5
END_DESCRIPTION

Parameter_S_input_price_growth

_INIT_
All 1 instances equal to 0
END_DESCRIPTION

Parameter_S_capital_price_growth

_INIT_
All 1 instances equal to 0
END_DESCRIPTION

Parameter_S_cpi_growth

_INIT_
All 1 instances equal to 0
END_DESCRIPTION

Parameter_S_competitiveness_adjustment

_INIT_
All 1 instances equal to 1
END_DESCRIPTION

Variable_S_Capital_Price

END_DESCRIPTION

Variable_S_CPI

END_DESCRIPTION

Variable_S_Input_Price

END_DESCRIPTION

Variable_S_Employment

END_DESCRIPTION

Parameter_S_capital_output_ratio

_INIT_
All 1 instances equal to 0.5
END_DESCRIPTION

Parameter_S_depreciation_period

_INIT_
All 1 instances equal to 50
END_DESCRIPTION

Parameter_S_payback_period

_INIT_
All 1 instances equal to 5
END_DESCRIPTION

Parameter_S_product_difficulty

_INIT_
All 1 instances equal to 0.75
END_DESCRIPTION

Parameter_S_product_patent

_INIT_
All 1 instances equal to 0
END_DESCRIPTION

Parameter_S_demand_scale

_INIT_
All 1 instances equal to 200
END_DESCRIPTION

Parameter_S_logistic_growth

_INIT_
All 1 instances equal to 0.02
END_DESCRIPTION

Parameter_S_demand_duration

_INIT_
All 1 instances equal to 150
END_DESCRIPTION

Variable_S_Firm_Exit
Firm exit process out of the industry
END_DESCRIPTION

Parameter_S_switch_exit

_INIT_
All 1 instances equal to 1
END_DESCRIPTION

Parameter_S_max_leverage_ratio

_INIT_
All 1 instances equal to 2.5
END_DESCRIPTION

Parameter_S_decline_delay_factor

_INIT_
All 1 instances equal to 2.5
END_DESCRIPTION

Parameter_S_min_market_share

_INIT_
All 1 instances equal to 0.001
END_DESCRIPTION

Variable_S_Market_Exit
Delete market if no firm produces its associated product.
To preserve model integrity, at least one MARKET instance must always remain.
END_DESCRIPTION

Variable_S_Firm_Number

END_DESCRIPTION

Variable_S_Sector_Normalized_HHI
Sector-level normalized Herfindahl-Hirschman Index (HHI).
Weighted average of each market's normalized HHI, weighted by the number of firms.
END_DESCRIPTION

Variable_S_Avg_Debt_Rate

END_DESCRIPTION

Parameter_S_logistic_degrowth

_INIT_
All 1 instances equal to 0.01
END_DESCRIPTION

Variable_S_Avg_Profit_Rate
Sector-level average product profit rate.
Computed as the production-weighted average of product-level profit rates.
END_DESCRIPTION

Object_FIRM

END_DESCRIPTION

Variable_F_Wage

END_DESCRIPTION

Variable_F_Avg_Productivity

END_DESCRIPTION

Variable_F_Capacity_Utilization

END_DESCRIPTION

Variable_F_Debt_Payment

END_DESCRIPTION

Variable_F_Distributed_Profits

END_DESCRIPTION

Variable_F_Effective_Production

END_DESCRIPTION

Variable_F_Financial_Obligations

END_DESCRIPTION

Variable_F_Frontier_Productivity

END_DESCRIPTION

Variable_F_Imitation_Productivity

END_DESCRIPTION

Variable_F_Innovation_Productivity

END_DESCRIPTION

Variable_F_Interest_Payment

END_DESCRIPTION

Variable_F_Net_Profits

END_DESCRIPTION

Variable_F_Productivity_RND_Expenses

END_DESCRIPTION

Variable_F_Profit_Rate

END_DESCRIPTION

Variable_F_Retained_Profits

_INIT_
All 1 instances equal to 0
END_DESCRIPTION

Parameter_F_debt_repayment

_INIT_
All 1 instances equal to 0.025
END_DESCRIPTION

Parameter_F_expectations

_INIT_
All 1 instances equal to 0.3
END_DESCRIPTION

Parameter_F_markup_adjustment

_INIT_
All 1 instances equal to 0.1
END_DESCRIPTION

Parameter_F_markup_passthrough_tax

_INIT_
All 1 instances equal to 0
END_DESCRIPTION

Parameter_F_productivity_innovation_share

_INIT_
All 1 instances equal to 0.5
END_DESCRIPTION

Parameter_F_productivity_rnd_proportion

_INIT_
All 1 instances equal to 0.05
END_DESCRIPTION

Parameter_F_profits_distribution_rate

_INIT_
All 1 instances equal to 0.9
END_DESCRIPTION

Parameter_F_strategic_price_weight

_INIT_
All 1 instances equal to 0.5
END_DESCRIPTION

Parameter_F_desired_degree_capacity_utilization

_INIT_
All 1 instances equal to 0.8
END_DESCRIPTION

Variable_F_Capital

_INIT_
All 1 instances equal to 100
END_DESCRIPTION

Variable_F_Demand_Capital_Goods_Expansion

_INIT_
All 1 instances equal to 0
END_DESCRIPTION

Variable_F_Demand_Capital_Goods_Replacement

END_DESCRIPTION

Variable_F_Desired_Expansion_Investment_Expenses

END_DESCRIPTION

Variable_F_Desired_Replacement_Investment_Expenses

END_DESCRIPTION

Variable_F_Expected_Sales

END_DESCRIPTION

Variable_F_Productive_Capacity

END_DESCRIPTION

Variable_F_Productive_Capacity_Depreciation

END_DESCRIPTION

Parameter_F_product_innovation_share

_INIT_
All 10 instances equal to 1
END_DESCRIPTION

Variable_F_Innovation_Product

END_DESCRIPTION

Parameter_F_id

_INIT_
All 10 instances equal to 1
END_DESCRIPTION

Variable_F_Imitation_Product
Firm product imitation. Dpends on the sucess of the imitation process, which in turn depends on the resources allocated. If success, firm starts producing a new (but already existing) product)
END_DESCRIPTION

Variable_F_Investment_Expenses

END_DESCRIPTION

Variable_F_Product_Imitation_RND_Expenses
Firm product imitation rnd expenses. Share of total aftertax revenue allocated to product imitation rnd.
END_DESCRIPTION

Variable_F_Product_Innovation_RND_Expenses
Firm product innovation rnd expenses. Share of total aftertax revenue allocated to product innovation rnd.
END_DESCRIPTION

Parameter_F_date_birth

_INIT_
All 10 instances equal to 0
END_DESCRIPTION

Variable_F_Revenue

END_DESCRIPTION

Variable_F_Debt_Rate

_INIT_
All 1 instances equal to 0
END_DESCRIPTION

Variable_F_Stock_Deposits
Calculate new deposits stock after accounting for:
- previous deposits accruing interest,
- retained profits added to deposits,
- deposits used to cover debt payments, investment, and interest.
Logic:
- Deposits earn interest first.
- Retained profits increase available cash.
- Total needs (debt payment, investment, debt interest) reduce deposits.
- Deposits never go negative.
_INIT_
All 1 instances equal to 0
END_DESCRIPTION

Variable_F_Stock_Debt

_INIT_
All 1 instances equal to 0
END_DESCRIPTION

Parameter_F_debt_interest_rate

_INIT_
All 1 instances equal to 0.015
END_DESCRIPTION

Parameter_F_deposit_interest_rate

_INIT_
All 1 instances equal to 0.01
END_DESCRIPTION

Variable_F_Available_Funds

END_DESCRIPTION

Object_CAPITAL

END_DESCRIPTION

Parameter_C_production

_INIT_
All 1 instances equal to 0
END_DESCRIPTION

Parameter_C_productive_capacity

_INIT_
All 50 instances equal to 2
END_DESCRIPTION

Parameter_C_productivity

_INIT_
All 1 instances equal to 1
END_DESCRIPTION

Parameter_C_date_birth

_INIT_
All 10 instances equal to 0
END_DESCRIPTION

Parameter_C_depreciation_period

_INIT_
All 240 instances equal to 50
END_DESCRIPTION

Parameter_C_to_replace

_INIT_
All 10 instances equal to 0
END_DESCRIPTION

Object_PRODUCT

END_DESCRIPTION

Parameter_P_id

END_DESCRIPTION

Variable_P_Aftertax_Revenue

END_DESCRIPTION

Variable_P_Competitiveness

_INIT_
All 1 instances equal to 1
END_DESCRIPTION

Variable_P_Desired_Markup

END_DESCRIPTION

Variable_P_Effective_Market_Share

END_DESCRIPTION

Variable_P_Effective_Markup

END_DESCRIPTION

Variable_P_Effective_Orders

_INIT_
All 1 instances equal to 400
END_DESCRIPTION

Variable_P_Effective_Production

END_DESCRIPTION

Variable_P_Expected_Sales

_INIT_
All 1 instances equal to 0
END_DESCRIPTION

Variable_P_Imitation_Quality

END_DESCRIPTION

Variable_P_Indirect_Tax

END_DESCRIPTION

Variable_P_Innovation_Quality

END_DESCRIPTION

Variable_P_Inventories

_INIT_
All 10 instances equal to 1
END_DESCRIPTION

Variable_P_Market_Share

_INIT_
All 1 instances equal to 1
END_DESCRIPTION

Variable_P_Planned_Production

END_DESCRIPTION

Variable_P_Price

END_DESCRIPTION

Variable_P_Quality

END_DESCRIPTION

Variable_P_Quality_RND_Expenses

END_DESCRIPTION

Variable_P_Revenue

END_DESCRIPTION

Variable_P_Sales

END_DESCRIPTION

Variable_P_Variable_Cost

END_DESCRIPTION

Parameter_P_desired_inventories_proportion

_INIT_
All 1 instances equal to 0.1
END_DESCRIPTION

Parameter_P_indirect_tax_rate

_INIT_
All 1 instances equal to 0.1
END_DESCRIPTION

Parameter_P_input_tech_coefficient

_INIT_
All 1 instances equal to 0.3
END_DESCRIPTION

Parameter_P_quality_innovation_share

_INIT_
All 1 instances equal to 0.5
END_DESCRIPTION

Parameter_P_quality_rnd_proportion

_INIT_
All 1 instances equal to 0.05
END_DESCRIPTION

Parameter_P_desired_market_share

_INIT_
All 1 instances equal to 0.5
END_DESCRIPTION

Variable_P_Profits

END_DESCRIPTION

Variable_P_Profit_Rate

END_DESCRIPTION

Variable_P_Avg_Market_Share
Average Market Share between the market share of the firm in the last markup period
_INIT_
All 1 instances equal to 1
END_DESCRIPTION

Variable_P_Desired_Market_Share
Desired markup over each product. Desired Market Share is a simple average between last period's desired market share and firm's average market share for each product.
_INIT_
All 1 instances equal to 1
END_DESCRIPTION

Variable_P_Innovation_RND_Share
This variable defines the allocation of expenses between innovation and imitation.
If the firm is gaining market share, it decreases imitation and increases innovation. The opposite is valid.
_INIT_
All 1 instances equal to 0.5
END_DESCRIPTION

Variable_P_Product_Imitation_RND_Expenses
Product RND expenses. Share of aftertax revenue allocated to product rnd
END_DESCRIPTION

Variable_P_Product_Innovation_RND_Expenses
Product RND expenses. Share of aftertax revenue allocated to product rnd
END_DESCRIPTION

Variable_P_Product_RND_Share

_INIT_
All 1 instances equal to 0.1
END_DESCRIPTION

Variable_P_Quality_RND_Share
This variable defines the share of expenses of quality rnd.
If the firm is gaining market share, it decreases quality rnd. The opposite is also true.
_INIT_
All 1 instances equal to 0.01
END_DESCRIPTION

Parameter_P_product_rnd_share_max

_INIT_
All 1 instances equal to 1
END_DESCRIPTION

Parameter_P_quality_rnd_share_max

_INIT_
All 1 instances equal to 1
END_DESCRIPTION

Parameter_P_innovation_imitation_adjustment

_INIT_
All 10 instances equal to 0.015
END_DESCRIPTION

Parameter_P_markup_period

_INIT_
All 10 instances equal to 4
END_DESCRIPTION

Parameter_P_product_adjustment

_INIT_
All 1 instances equal to 0.01
END_DESCRIPTION

Parameter_P_quality_adjustment

_INIT_
All 1 instances equal to 0.01
END_DESCRIPTION

Variable_P_Total_Variable_Cost
Total variable production cost of this product.
= P_Effective_Production * P_Variable_Cost
END_DESCRIPTION

Parameter_P_innovation_adjustment

_INIT_
All 1 instances equal to 0.02
END_DESCRIPTION

Parameter_P_innovation_floor

_INIT_
All 1 instances equal to 0.01
END_DESCRIPTION

Parameter_P_innovation_zone_parameter

_INIT_
All 1 instances equal to 0.5
END_DESCRIPTION

Parameter_P_resource_share_required

_INIT_
All 1 instances equal to 0.1
END_DESCRIPTION

Parameter_P_rnd_shrink

_INIT_
All 1 instances equal to 0.5
END_DESCRIPTION

Object_MARKET

END_DESCRIPTION

Parameter_M_id

END_DESCRIPTION

Parameter_M_elasticity_price

_INIT_
All 1 instances equal to 1
END_DESCRIPTION

Parameter_M_elasticity_quality

_INIT_
All 1 instances equal to 1
END_DESCRIPTION

Variable_M_Avg_Competitiveness

_INIT_
All 1 instances equal to 1
END_DESCRIPTION

Variable_M_Avg_Price

END_DESCRIPTION

Variable_M_Effective_Orders

_INIT_
All 1 instances equal to 100
END_DESCRIPTION

Variable_M_Sales

END_DESCRIPTION

Parameter_M_real_demand_growth

_INIT_
All 1 instances equal to 0.05
END_DESCRIPTION

Parameter_M_date_birth

_INIT_
All 1 instances equal to 0
END_DESCRIPTION

Variable_M_Avg_Sales
Market Sales. Sum of all firms sales.
_INIT_
All 1 instances equal to 100
END_DESCRIPTION

Variable_M_Number_Potential_Entrants

END_DESCRIPTION

Parameter_M_entry_barrier

_INIT_
All 1 instances equal to 0.5
END_DESCRIPTION

Parameter_M_max_demand

_INIT_
All 1 instances equal to 500
END_DESCRIPTION

Parameter_M_switch_entry

_INIT_
All 1 instances equal to 1
END_DESCRIPTION

Parameter_M_max_entry_number

_INIT_
All 1 instances equal to 3
END_DESCRIPTION

Variable_M_Market_Share_Adjustment

END_DESCRIPTION

Variable_M_Avg_Market_Share
Market Avg Market Share. One divided by the number of firms within this market.
_INIT_
All 1 instances equal to 1
END_DESCRIPTION

Variable_M_Firm_Entry
Firm entry process into each market
END_DESCRIPTION

Variable_M_Firm_Market_Exit
Firm exit process out of each market
END_DESCRIPTION

Variable_M_Market_Normalized_HHI
Market Variable for Analysis
END_DESCRIPTION

Variable_M_Market_Firm_Number

END_DESCRIPTION

Variable_M_Market_Avg_Productive_Capacity
Average productive capacity of firms active in this market.
Each firm's productive capacity is weighted by its product's market share in the market.
END_DESCRIPTION


DOCUOBSERVE

END_DOCUOBSERVE


DOCUINITIAL

END_DOCUINITIAL


EQ_FILE
//#define EIGENLIB			// uncomment to use Eigen linear algebra library

#include "fun_head_fast.h"

// do not add Equations in this area

MODELBEGIN

// insert your equations here, ONLY between the MODELBEGIN and MODELEND words


////////////////// EXOGENOUS VARIABLES ///////////////////////


EQUATION("S_Capital_Price")
/*
Sector price of capital. Current price multiplied by a exogenous growth rate.
*/		
v[0]=VL("S_Capital_Price",1);                                                          	 
v[1]=V("S_capital_price_growth");																                    							
v[2]=v[0]*(1+v[1]);                                              					                                                                     			
RESULT(v[2])

EQUATION("S_Input_Price")
/*
Sector price of inputs. Current price multiplied by a exogenous growth rate.
*/		
v[0]=VL("S_Input_Price",1);                                                          	 
v[1]=V("S_input_price_growth");																                    							
v[2]=v[0]*(1+v[1]);                                              					                                                                  			
RESULT(v[2])

EQUATION("S_CPI")
/*
Sector CPI. Current value multiplied by a exogenous growth rate.
*/	
v[0]=VL("S_CPI",1);                                                          	 
v[1]=V("S_cpi_growth");																                    							
v[2]=v[0]*(1+v[1]);                                              					                                                                   			
RESULT(v[2])


////////////////// COST AND PRICES ///////////////////////


EQUATION("F_Wage")
/*
Firm Wage. Adjusted every period based on the growth rate of firm productivity, inflation and growth rate of sectoral employment, adjusted by the respective passthrough parameters.
*/
v[0]=VL("F_Wage",1);   
	                                                       	 			
v[3]=VL("F_Avg_Productivity", 1);                                           	 			
v[4]=VL("F_Avg_Productivity", 2);                                     			
if(v[4]!=0)
	v[5]=(v[3]-v[4])/v[4];//productivity growth                                        			
else
	v[5]=0;
		
v[6]=VL("S_CPI", 1);                                								
v[7]=VL("S_CPI", 2);                        								
if(v[7]!=0)
	v[8]=(v[6]-v[7])/v[7];//inflation                                                     			
else
	v[8]=0;
		
v[12]=VL("S_Employment", 1);                                							
v[13]=VL("S_Employment", 2);                        							
if(v[13]!=0)
	v[14]=(v[12]-v[13])/v[13];//employment growth                                                   		
else
	v[14]=0;
		
v[9]=V("S_wage_passthrough_productivity");                                       				
v[10]=V("S_wage_passthrough_inflation");														
v[11]=V("S_wage_passthrough_employment");	
v[15]=v[0]*(1+v[5]*v[9]+v[8]*v[10]+v[11]*v[14]);                                           

if (v[15] <= 0)
	v[15]=v[0];
			
RESULT(v[15])


EQUATION("P_Variable_Cost")
/*
Product Variable Cost. Depends on the firm wage and average productivity, labour cost (the same for all products of the firm) and the input cost, which is different for each product.
*/
v[1]=V("F_Wage");
v[2]=VL("F_Avg_Productivity",1); 
v[3]=V("P_input_tech_coefficient");                               			  
v[4]=V("S_Input_Price");           
if(v[2]!=0)
	v[5]=(v[1]/v[2])+(v[3]*v[4]);
else
	v[5]=0;	
	

RESULT(v[5])


EQUATION("P_Desired_Markup")
/*
Desired markup adjustment rule:
- If desired market share > actual share ? reduce markup (to gain competitiveness).
- If desired market share < actual share ? increase markup (to capture more profit).
- If equal ? keep previous markup.
*/
v[0] = V("P_id");
v[1] = VL("P_Desired_Markup", 1);        // previous desired markup
v[2] = V("P_Desired_Market_Share");      // target market share
v[3] = VL("P_Market_Share", 1);          // last period market share
v[4] = V("F_markup_adjustment");         // adjustment step

if (v[2] > v[3])
    v[5] = v[1] - v[4];                  // decrease markup
else if (v[2] < v[3])
    v[5] = v[1] + v[4];                  // increase markup
else
    v[5] = v[1];                         // keep as is

if (v[5] < 1)                            // lower bound safeguard
    v[5] = 1;

RESULT(v[5])


EQUATION("P_Desired_Market_Share")
/*
Desired markup over each product. Desired Market Share is a simple average between last period's desired market share and firm's average market share for each product.
*/
	v[0]=V("P_markup_period");								//mark up period parameter
	v[1]=fmod((t+v[0]),v[0]);								//devides the current time step by the markup period and takes the rest
	v[2]=V("P_id");						            		//product id
	v[3]=fmod((v[2]+v[0]),v[0]);							//divides the product id by the investment period and takes the rest
	v[4]=VL("P_Desired_Market_Share", 1);                  	//desired market share in the last period
	v[5]=VL("P_Avg_Market_Share", 1);                      	//product's average market share (desired)
	if(v[3]==v[1])                                         	//if the rest of the above division is zero, adjust desired market share
		v[6]=(v[4]+v[5])/2;                                 //current desired market share is a simple average between last period's desired market share and product's average market share
	else                                            		//if the rest of the above division is not zero, do not adjust desired market share
 		v[6]=v[4];                                			//product's desired market share will be equal to the last period's
 		
RESULT(v[6])


EQUATION("P_Avg_Market_Share")
/*
Average Market Share between the market share of the firm in the last markup period
*/
	v[0]=V("P_markup_period");
	v[3]=0;										   			//initializes the sum
	for (v[1]=1; v[1]<=(v[0]-1); v[1]=v[1]+1)		    	//from 0 to markup period-1 lags
		{
		v[2]=VL("P_Market_Share", v[1]);					//computates product's market share of the current lag
		v[3]=v[3]+v[2];										//sum up product's lagged market share
		}
	v[4]=v[3]/v[0];											//average product's market share of the last investment period

RESULT(v[4])

EQUATION("P_Price")
/*
Product Price. Is a weighted average between the firm's desired price for that product (desired markup over the variable cost) and the average price of the product.
*/
v[0]=VL("P_Price",1);                                                   						
v[1]=V("P_Variable_Cost");                          											
v[2]=V("P_Desired_Markup");                         											
v[3]=V("F_strategic_price_weight");  
cur = SEARCH_CNDS(GRANDPARENT, "M_id", V("P_id"));                                 						
v[4]=VLS(cur, "M_Avg_Price", 1);                                            						
v[5]=v[3]*(v[1]*v[2])+(1-v[3])*(v[4]);                                          				                                                         					
v[6]=V("P_indirect_tax_rate");
v[7]=V("F_markup_passthrough_tax");
v[9]= 1 - (v[7]*v[6]);
if (v[9] <= exp(-9))
	v[9] = exp(-9);

v[8]=v[5]/v[9];

if (v[8] <= 0)
	v[8] = (v[0] > 0 ? v[0] : v[1]*max(1.0, v[2]));
	
RESULT(v[8])


EQUATION("P_Effective_Markup")
/*
Product Effective Markup. Effective price over variable cost.
*/
v[0]=V("P_Price");
v[1]=V("P_Variable_Cost");
if(v[1]>0)
	v[2]=v[0]/v[1];
else
	v[2]=0;
RESULT(v[2])


////////////////// COMPETITIVENESS AND MARKET SHARE ///////////////////////


EQUATION("P_Competitiveness")
/*
Product Competitiveness. Depends negatively on price and positively on quality.
*/
cur = SEARCH_CNDS(GRANDPARENT, "M_id", V("P_id"));                                 						 												
v[0]=VL("P_Price",1);                                          								
v[1]=VS(cur,"M_elasticity_price");                                        						
v[2]=VL("P_Quality",1);                                         								
v[3]=VS(cur,"M_elasticity_quality");                                      							v[4] = exp(-9);
v[6] = exp(9);
v[7] = VL("P_Competitiveness",1);

// sanitize inputs
if (v[0] < v[4]) v[0] = v[4];
if (v[2] < v[4]) v[2] = v[4];
	
if(v[0]>0 && v[2]>0)     
	// core formula:                                          					
   v[5]=(pow(v[2],v[3]))*(1/pow(v[0],v[1]));   								
else                                                               								
   v[5]=v[7];    
   
   // avoid extreme values 
if (v[5] < v[4]) 
v[5] = v[4];
else if (v[5] > v[6]) 
v[5] = v[6];	
                                                 								
RESULT(v[5])


EQUATION("P_Market_Share")
/*
Product Market Share. Adjusted based on the difference between firm's competitiveness and the average competitiveness of the market. Firms above the average gain market share, firms below the average lose market share.
*/
v[0]=VL("P_Market_Share", 1);      
cur = SEARCH_CNDS(GRANDPARENT, "M_id", V("P_id"));                                 						 												
v[1]=VS(cur,"M_Avg_Competitiveness");          													
v[2]=V("S_competitiveness_adjustment");										
v[3]=V("P_Competitiveness");     
            												
	if (v[1] > 0)                                     												
	v[4] = v[0] + v[2] * v[0] * ((v[3] / v[1]) - 1);             								
	else
	v[4]=v[0];                                        												
	if (v[4] < 0)
    	v[4] = 0;
	if (v[4] > 1)
   	 	v[4] = 1;	  
	                                   												
RESULT(v[4])


////////////////// PRODUCTION ///////////////////////


EQUATION("P_Expected_Sales")
/*
Product Expected Sales. Simple adaptative expectational rules based on past demand.
*/
v[1]=VL("P_Effective_Orders", 1);                    										
v[2]=VL("P_Effective_Orders", 2);                    										
v[3]=V("F_expectations");                            												
if(v[2]!=0)                                           											
	v[4]=max(0,v[1]*(1+v[3]*((v[1]-v[2])/v[2])));              										
else                                                  											
	v[4]=v[1]; 	                                        											
RESULT(v[4])


EQUATION("P_Planned_Production")
/*
Product Planned Production. Based on expected sales considering existing and desired inventories.
*/
v[1]=V("P_Expected_Sales");                          										
v[2]=V("P_desired_inventories_proportion");             										
v[3]=VL("P_Inventories",1);                    										
v[4]=v[1]*(1+v[2])-v[3]; 
// planned production cannot be negative   
if (v[4] < 0) 
v[4] = 0;    
                    											
RESULT(v[4])


EQUATION("F_Effective_Production")
/*
Firm Effective Production. Firm will calculate the planned production for all products and consider the entire productive capacity. Higher profit rate produts will be produced first. More productive capital goods will be used first.
*/
CYCLE(cur, "CAPITAL")
	{
	WRITES(cur, "C_production", 0 );							// intitilize the production of each capital good as zero.
	}

SORTL("PRODUCT", "P_Profit_Rate", "DOWN", 1);					// sort products by past profit rates
v[7]=0;
CYCLE(cur, "PRODUCT") 											// cycle through all products                                                                      
	{
	v[0]=VS(cur,"P_Planned_Production");                                                              			
	SORT("CAPITAL", "C_productivity", "DOWN");   				//sort capital goods by productivity                                     
	v[1]=0;                                                                                      	
		CYCLES(PARENT, cur1, "CAPITAL")  						// cycle through all capital goods                                                                       
		{
		v[2]=VS(cur1, "C_productive_capacity");
		v[3]=VS(cur1, "C_production");   
		                    
		v[4]=max(0,(min(v[2]-v[3], v[0])));                     //for each capital good, it produced the minimum between the planned production and the capital productive capacity                                                    	
		INCRS(cur1, "C_production", v[4]);                      //write the capital good product                                     
		v[0]=v[0]-v[4];                                                                            	
		v[1]=v[1]+v[4];                                                                            	
		}
	WRITES(cur, "P_Effective_Production", v[1]);
	v[7]=v[7]+v[1];
	}

RESULT(v[7])

EQUATION_DUMMY("P_Effective_Production", "F_Effective_Production")


EQUATION("F_Avg_Productivity")
/*
Firm Avg Productivity. To be used in the variable cost calculation. Weighted average of each capital good productivity weighted by the production.
*/                            							                   									
v[2]=0;                                                        									
v[3]=0;                                                        									
CYCLE(cur, "CAPITAL")                                          								
	{
	v[4]=VS(cur, "C_productivity");                   								
	v[5]=VS(cur, "C_production");                    								
	v[2]=v[2]+v[4]*v[5];                                        								
	v[3]=v[3]+v[5];                                             								
	}
if (v[3]>0)                                                   									
	v[6]=v[2]/v[3];                                             								
else                                                           									
	v[6]=VL("F_Avg_Productivity", 1);  	                                                 								
RESULT(v[6])


EQUATION("F_Capacity_Utilization")
/*
Firm Capacity Utilization. Effective Production over total productive capacity
*/
v[0]=V("F_Effective_Production");
v[1]=SUM("C_productive_capacity");
if(v[1]>0)
		v[2]=v[0]/v[1];
else
		v[2]=0;	
		
  //[0, 1]
if (v[2] < 0) v[2] = 0;
if (v[2] > 1) v[2] = 1;

RESULT(v[2])


////////////////// DEMAND AND SALES ///////////////////////


EQUATION("M_Effective_Orders")
/*
Market Effective Orders. Total Demand.
*/
v[0]=V("M_date_birth");
v[1]=V("S_demand_scale");
v[2]=V("S_logistic_growth");
v[8]=V("S_logistic_degrowth");
v[3]=V("S_demand_duration");
v[4]=V("S_decline_delay_factor");	                        //delay factor for the onset of the decline
v[5]=1/(1 + exp(-v[2] * ((double)t - v[0] - v[3])));   	    //rising logistically
v[6]=1/(1 + exp( v[8] * ((double)t - v[0] - v[4]*v[3])));   //declining logistically
v[7]=v[1]*v[5]*v[6];								    	//bell-shaped curve

if (v[7] < 0) v[7] = 0;

RESULT(v[7])


EQUATION("P_Effective_Orders")
/*
Product Effective Orders. Market effective orders distributed by the market share.
*/
v[1]=V("P_Market_Share");
cur = SEARCH_CNDS(GRANDPARENT, "M_id", V("P_id"));                                 						 												
v[2]=VS(cur, "M_Effective_Orders");
v[3]=v[1]*v[2];

RESULT(v[3])


EQUATION("P_Sales")
/*
Product Sales. Minimum between supply (production and inventories) and demand.
*/
v[0]=VL("P_Inventories",1);                   												
v[1]=V("P_Effective_Production");                   											
v[2]=V("P_Effective_Orders");                       												
if (v[0] < 0) v[0] = 0;
if (v[1] < 0) v[1] = 0;
if (v[2] < 0) v[2] = 0;

v[3]=v[0]+v[1];                                        											
v[4]=max(0, min(v[3],v[2]));                           												
RESULT(v[4])


EQUATION("P_Inventories")
/*
Product Inventories. Adjusted by the difference between sales and production.
*/
v[0]=V("P_Effective_Production");                    											            
v[1]=V("P_Sales");                                   											
v[2]=VL("P_Inventories", 1);  
                												
v[3]=max(0, v[0]-v[1]+v[2]);                                   											
RESULT(v[3])


EQUATION("P_Effective_Market_Share")
/*
Product Effective Market Share. Firm Sales over Market sales.
*/
v[0]=V("P_Sales");
cur = SEARCH_CNDS(GRANDPARENT, "M_id", V("P_id"));                                 						 												
v[1]=VS(cur, "M_Sales");
if (v[1] > 0)
    v[2]=v[0]/v[1];
else
    v[2]=0;
    
if (v[2] > 1) 
v[2] = 1;
	
RESULT(v[2])


EQUATION("P_Revenue")
/*
Product Revenue. Sales times price.
*/
v[0]=V("P_Sales");                                             									
v[1]=V("P_Price");                                             										
if (v[0] < 0) v[0] = 0;
if (v[1] < 0) v[1] = 0;

v[2]=v[0]*v[1];	

RESULT(v[2])


EQUATION("P_Indirect_Tax")
/*
Product Tax. Product indirect tax rate over the product revenue.
*/
v[0]=V("P_Revenue");
v[1]=V("P_indirect_tax_rate");
v[2]=v[0]*v[1];
RESULT(v[2])


EQUATION("P_Aftertax_Revenue")
/*
Product After Tax Revenue. Product revenue minus taxes
*/
v[0]=V("P_Revenue");
v[1]=V("P_indirect_tax_rate");
v[2]=v[0]*(1-v[1]);
RESULT(v[2])


////////////////// PROFITS ///////////////////////



EQUATION("P_Profits")
/*
Product Profit. Revenue minus tax minus production costs. To be used for profit rate calculation. Not for proper firm accounting.
*/
v[0]=V("P_Revenue");
v[1]=V("P_indirect_tax_rate");
v[2]=V("P_Effective_Production");
v[3]=V("P_Variable_Cost");
v[4]=v[0]*(1-v[1])-v[2]*v[3];
RESULT(v[4])


EQUATION("P_Profit_Rate")
/*
Product Profit Rate. Product profit over firm capital.
*/
v[0]=V("P_Profits");
v[1]=VL("F_Capital",1);
if(v[1]!=0)
	v[2]=v[0]/v[1];
else
	v[2]=0;	
RESULT(v[2])


EQUATION("P_Quality_RND_Expenses")
/*
Product Quality RND expenses. Share of aftertax revenue allocated to quality rnd
*/
v[0]=V("P_Aftertax_Revenue");
v[1]=V("P_Quality_RND_Share");    // endogenised
v[2]=v[0]*v[1];
RESULT(v[2])

EQUATION("P_Quality_RND_Share")
/*
Product-level QUALITY R&D intensity (share of after-tax revenue devoted to quality improvements).
Heuristic:
 - compute gap = desired_market_share - last_avg_market_share
   (positive => firm wants to grow ? increase R&D intensity)
   (negative => firm may reduce R&D but not below a floor, reduction shrunk)
 - apply deadband
 - enforce floor and ceiling
*/

v[0] = V("P_Desired_Market_Share");         
v[1] = VL("P_Avg_Market_Share", 1);          
v[2] = VL("P_Quality_RND_Share", 1);        
v[3] = V("P_quality_adjustment");            
v[4] = V("P_quality_rnd_share_max");         
v[5] = V("P_innovation_floor");         
v[6] = V("P_rnd_shrink");                    
v[7] = V("P_innovation_zone_parameter");        // deadband tolerance
v[8] = v[3] * v[7];

// compute gap
v[9] = v[0] - v[1];

// apply deadband
if (abs(v[9]) <= v[8]) 
	v[10] = v[2];   
else 
	{
	if (v[9] > 0)
		v[10] = v[2] + v[3] * v[9];        
	else
		v[10] = v[2] + v[3] * v[9] * v[6]; 
	}

// enforce floor and ceiling
if (v[10] < v[5]) v[10] = v[5];
if (v[10] > v[4]) v[10] = v[4];

RESULT(v[10])

EQUATION("F_Interest_Payment")
/*
Firm Interest Payment. Interest on existing stock of debt.
*/
v[0]=V("F_debt_interest_rate");
v[1]=VL("F_Stock_Debt",1);
v[2]=v[0]*v[1];	                                   			               
RESULT(v[2])								

EQUATION("F_Debt_Payment")
/*
Firm Debt Payment / Amortization on existing stock of debt.
*/
v[0] = V("F_debt_repayment");
v[1] = VL("F_Stock_Debt", 1);
v[2] = v[0] * v[1];
RESULT(v[2])

EQUATION("F_Financial_Obligations")
/*
Firm financial obligations. Interest payments plus amortization.
*/
v[1]=V("F_Interest_Payment");
v[2]=V("F_Debt_Payment");
v[3]=v[1]+v[2]; 
RESULT(v[3])


EQUATION("F_Productivity_RND_Expenses")
/*
Firm productivity rnd expenses. Share of total aftertax revenue allocated to productivity rnd.
*/
v[1]=SUM("P_Aftertax_Revenue");
v[2]=V("F_productivity_rnd_proportion");    
v[3]=v[1]*v[2]; 
RESULT(v[3])



EQUATION("P_Product_Innovation_RND_Expenses")
/*
Product RND expenses. Share of aftertax revenue allocated to product rnd
*/
v[0]=V("P_Aftertax_Revenue");
v[1]=V("P_Product_RND_Share");    // endogenised
v[2]=V("P_Innovation_RND_Share");
v[3]=v[0]*v[1]*v[2];
RESULT(v[3])

EQUATION("P_Product_Imitation_RND_Expenses")
/*
Product RND expenses. Share of aftertax revenue allocated to product rnd
*/
v[0]=V("P_Aftertax_Revenue");
v[1]=V("P_Product_RND_Share");    // endogenised
v[2]=V("P_Innovation_RND_Share");
v[3]=v[0]*v[1]*(1-v[2]);
RESULT(v[3])

EQUATION("P_Innovation_RND_Share")
/*
Fraction of product R&D allocated to INNOVATION (complement goes to imitation).
Heuristic:
 - compute gap = avg_market_share - desired_market_share
   (positive => firm overperforms ? consolidate, increase innovation;
    negative => firm underperforms ? fallback to imitation)
 - apply deadband (no adjustment if gap small)
 - apply shrink factor for reductions
 - enforce floor and ceiling
*/

v[0] = V("P_Desired_Market_Share");          
v[1] = VL("P_Avg_Market_Share", 1);          
v[2] = VL("P_Innovation_RND_Share", 1);     
v[3] = V("P_innovation_adjustment");        
v[4] = V("P_innovation_zone_parameter");     // deadband tolerance parameter
v[5] = V("P_innovation_floor");              
v[6] = V("P_rnd_shrink");                   // shrink factor when reducing
v[7] = v[3] * v[4];

// compute gap
v[8] = v[1] - v[0];   

// deadband: no adjustment if gap is small
if (abs(v[8]) <= v[7]) 
	v[9] = v[2];
else 
	{
	if (v[8] > 0)
		v[9] = v[2] + v[3] * v[8];        // increase innovation share
	else
		v[9] = v[2] + v[3] * v[8] * v[6]; // decrease shrunkenly
	}

// floor and ceiling
if (v[9] < v[5])   v[9] = v[5];
if (v[9] > 0.99)   v[9] = 0.99;

RESULT(v[9])

EQUATION("P_Product_RND_Share")
/*
Total product-level R&D intensity (share of after-tax revenue devoted to PRODUCT R&D).
Heuristic:
 - compute gap = desired_market_share - last_avg_market_share
   (positive => increase R&D intensity)
   (negative => firm may reduce R&D but not below a floor, reduction shrunk)
 - apply deadband
 - resource_factor conditions adjustment by available funds
 - enforce floor and ceiling
*/

v[0] = V("P_Desired_Market_Share");          
v[1] = VL("P_Avg_Market_Share", 1);           
v[2] = VL("P_Product_RND_Share", 1);          
v[3] = V("P_product_adjustment");             
v[4] = V("P_product_rnd_share_max");          
v[5] = V("P_innovation_floor");         
v[6] = V("P_resource_share_required");        
v[7] = V("P_rnd_shrink");                    
v[8] = V("P_innovation_zone_parameter");         // deadband tolerance parameter
v[9] = v[3] * v[8];

// compute gap
v[10] = v[0] - v[1];

// resource factor
v[11] = VS(PARENT, "F_Available_Funds");      
v[12] = V("P_Aftertax_Revenue");              
v[13] = abs(v[10]) * v[12] * v[6];           
if (v[13] <= 0)
    v[14] = 1;
else
    v[14] = min(1, v[11] / v[13]);

// deadband
if (abs(v[10]) <= v[9])
	v[15] = v[2];   
else 
	{
	if (v[10] > 0)
		v[15] = v[2] + v[3] * v[10] * v[14];           
	else
		v[15] = v[2] + v[3] * v[10] * v[7] * v[14];    
	}

// enforce floor and ceiling
if (v[15] < v[5]) v[16] = v[5];
if (v[15] > v[4]) v[16] = v[4];

RESULT(v[15])


EQUATION("F_Product_Innovation_RND_Expenses")
/*
Firm product innovation rnd expenses. Share of total aftertax revenue allocated to product innovation rnd.
*/
v[1]=SUM("P_Product_Innovation_RND_Expenses");
RESULT(v[1])


EQUATION("F_Product_Imitation_RND_Expenses")
/*
Firm product imitation rnd expenses. Share of total aftertax revenue allocated to product imitation rnd.
*/
v[1]=SUM("P_Product_Imitation_RND_Expenses");
RESULT(v[1])

EQUATION("P_Total_Variable_Cost")
/*
Total variable production cost of this product.
= P_Effective_Production * P_Variable_Cost
*/
v[0] = V("P_Effective_Production");
v[1] = V("P_Variable_Cost");
v[2] = v[0] * v[1];

RESULT(v[2])

EQUATION("F_Net_Profits")
/*
Firm Net profits = total aftertax revenue - R&D - financial obligations - total production costs.
*/
v[0]=SUM("P_Aftertax_Revenue");                                        
v[1]=SUM("P_Quality_RND_Expenses");                              
v[2]=V("F_Productivity_RND_Expenses");                                     
v[3]=V("F_Product_Innovation_RND_Expenses");
v[4]=V("F_Product_Imitation_RND_Expenses");							  
v[5]=V("F_Financial_Obligations");
v[6]=SUM("P_Total_Variable_Cost");   
v[7]=v[0]-v[1]-v[2]-v[3]-v[4]-v[5]-v[6];								  									
RESULT(v[7])


EQUATION("F_Distributed_Profits")
/*
Firm distributed profits. Fixed share of total profits, only if positive.
*/
v[0]=V("F_Net_Profits");                                        											          
v[1]=V("F_profits_distribution_rate");                               											
if(v[0]>0)                                                         											
	v[2]=v[1]*v[0];                                                											
else                                                               											                                                                  
	v[2]=0;																											
RESULT(v[2])


EQUATION("F_Retained_Profits")
/*
Firm retained profits. To be used as funds for investmemt. If profits are negative, they are all retained.
*/
v[0]=V("F_Net_Profits");                                        											       
v[1]=V("F_profits_distribution_rate");                               											                           
if(v[0]>0)                                                         											
	v[2]=(1-v[1])*v[0];                                           											
else                                                               											                                                                    
	v[2]=v[0];                                                     											                                                         
RESULT(v[2])


EQUATION("F_Profit_Rate")
/*
Firm Profit Rate. Firm profits over firm capital
*/
v[0]=V("F_Net_Profits");
v[1]=VL("F_Capital",1);
if(v[1]!=0)
	v[2]=v[0]/v[1];
else
	v[2]=0;	
RESULT(v[2])


////////////////// R&D ///////////////////////


EQUATION("F_Frontier_Productivity")
/*
Firm frontier productivity. Maximum between existing one, innovation one and imitation one.
*/
v[0]=VL("F_Frontier_Productivity", 1);      
v[1]=V("F_Imitation_Productivity");         
v[2]=V("F_Innovation_Productivity");         
v[3]=max(v[0],max(v[1],v[2]));             		
RESULT(v[3])


EQUATION("F_Imitation_Productivity")
/*
Firm imitation productivity. Depends on the imitation success. If succeeded, copies the maximum existing productivity of other firms. Sucess depends on the resources allocated.
*/
v[0]=V("F_Productivity_RND_Expenses");               
v[1]=V("F_Wage"); 		
v[2]=V("F_productivity_innovation_share");		
v[3]=(v[0]/v[1])*(1-v[2]);                    
v[4]=1-exp(-v[3]);                   		
if(RND<v[4])                              	
     v[5]=MAXLS(PARENT, "F_Avg_Productivity", 1);  
else                                      	
     v[5]=0;     	                              
RESULT(v[5])

EQUATION("F_Innovation_Productivity")
/*
Firm innovation productivity. Depends on the innovation success. If succeeded, obtain a new random productivity. Sucess depends on the resources allocated.
*/
v[0]=V("F_Productivity_RND_Expenses");               
v[1]=V("F_Wage"); 		
v[2]=V("F_productivity_innovation_share");		
v[3]=(v[0]/v[1])*(v[2]);                    
v[4]=1-exp(-v[3]);                   		
if(RND<v[4])  
	{
	v[5]=V("S_std_dev_productivity");           
	v[6]=V("S_initial_productivity");			
	v[7]=V("S_tech_opportunity_productivity");
	v[8]=log(v[6])+(double)t*(v[7]);   		
	v[9]=exp(norm(v[8],v[5]));              
	}
else                                        
	v[9]=0;                                 
RESULT(v[9])


EQUATION("P_Quality")
/*
Product frontier quality. Maximum between existing one, innovation one and imitation one.
*/
v[0]=VL("P_Quality", 1);       				
v[1]=V("P_Imitation_Quality");          		
v[2]=V("P_Innovation_Quality");         		
v[3]=max(v[0],max(v[1],v[2]));        			
RESULT(v[3])


EQUATION("P_Imitation_Quality")
/*
Product imitation quality. Depends on the imitation success. If succeeded, copies the maximum existing quality of other firms. Sucess depends on the resources allocated.
*/
v[0]=V("P_Quality_RND_Expenses");               
v[1]=V("F_Wage"); 		
v[2]=V("P_Innovation_RND_Share");		
v[3]=(v[0]/v[1])*(1-v[2]);                    
v[4]=1-exp(-v[3]);                   		
if(RND<v[4]) 
	{                             	
     v[5]=V("P_id");
     v[8]=0;
     	CYCLES(GRANDPARENT, cur, "FIRM")
     	{
     		CYCLES(cur, cur1, "PRODUCT")
     		{
     			v[6]=VLS(cur1, "P_Quality", 1);	
     			v[7]=VS(cur1, "P_id");
     			if(v[6]>v[8]&&v[7]==v[5])
     				v[8] = v[6];
     			else
     				v[8] = v[8];
     		}
     	}
    }
else     	                                 	
     v[8]=0;       	                              
RESULT(v[8])


EQUATION("P_Innovation_Quality")
/*
Product innovation quality. Depends on the innovation success. If succeeded, obtain a new random quality. Sucess depends on the resources allocated.
*/
v[0]=V("P_Quality_RND_Expenses");               
v[1]=V("F_Wage"); 		
v[2]=V("P_Innovation_RND_Share");		
v[3]=(v[0]/v[1])*(v[2]);                    
v[4]=1-exp(-v[3]);                   		
if(RND<v[4])  
	{
	v[5]=V("S_std_dev_quality");           
	v[6]=V("S_initial_quality");			
	v[7]=V("S_tech_opportunity_quality");
	v[8]=log(v[6])+(double)t*(v[7]);   		
	v[9]=exp(norm(v[8],v[5]));              
	}
else                                        
	v[9]=0;                                 
RESULT(v[9])


EQUATION("F_Innovation_Product")
/*
Firm product innovation. Depends on the success of the innovation process,
which in turn depends on the resources allocated. If successful, firm creates
a new product (new PRODUCT object and corresponding MARKET object).
*/
v[5] = V("F_id");
v[0] = V("F_Product_Innovation_RND_Expenses");          
v[1] = V("F_Wage"); 			
v[2] = (v[0] / v[1]); 
v[3] = V("S_product_difficulty");                   
v[4] = 1 - exp(-v[2] * v[3]);                   		

if (RND < v[4])  
{
	// select random existing product of the firm as template
	cur  = RNDDRAW_FAIR("PRODUCT");
	v[6] = VS(cur, "P_id");                            
	cur1 = SEARCH_CNDS(PARENT, "M_id", v[6]);          
	
	// create new MARKET based on selected template
	cur2 = ADDOBJ_EXS(PARENT, "MARKET", cur1);         
	v[7] = MAXS(PARENT, "M_id");                       
	v[8] = v[7] + 1;                                   
	WRITES(cur2, "M_id", v[8]);                        
	WRITES(cur2, "M_date_birth", t);                   
	
	// initialize MARKET series
	WRITELLS(cur2, "M_Effective_Orders", 0, t-1, 1);   // lagged value
	WRITES  (cur2, "M_Effective_Orders", 0);           // current value
	
	PLOG("\nFirm %f", v[5]);
	PLOG("innovates and creates market %f", v[8]);
	PLOG("at time %f", T);
				
	// create new PRODUCT based on template
	cur3 = ADDOBJ_EX("PRODUCT", cur);                  
	WRITES(cur3, "P_id", v[8]);                        
	
	// initialize PRODUCT series
	WRITELLS(cur3, "P_Market_Share",      1, t-1, 1);
	WRITES  (cur3, "P_Market_Share",      1);
	WRITELLS(cur3, "P_Avg_Market_Share",  1, t-1, 1);
	WRITES  (cur3, "P_Avg_Market_Share",  1);
	WRITELLS(cur3, "P_Effective_Orders",  0, t-1, 1);
	WRITES  (cur3, "P_Effective_Orders",  0);
}
else                                        
	v[8] = 0;                                 

RESULT(v[8])

EQUATION("F_Imitation_Product")
/*
Firm product imitation.
- Success depends on resources allocated.
- If success, firm tries to imitate a product not yet produced by it.
- Eligible products: P_Profit_Rate > S_Avg_Profit_Rate (above sector average profitability).
- Among eligible products, imitation probability is proportional to profitability.
- Patent protection is respected (S_product_patent).
*/

v[0] = V("F_Product_Imitation_RND_Expenses");   
v[1] = V("F_Wage");                             
v[2] = v[0] / v[1];                             
v[3] = V("S_product_patent");                  
v[4] = 1 - exp(-v[2]);                          // imitation success probability

if (RND < v[4])                                 // imitation trial successful
{
    v[5] = V("F_id");                           // this firm's id
    v[6] = V("S_Avg_Profit_Rate");             

    //  1st cycle: collect candidates and total weight
    v[7] = 0;                                   // sum of profitability weights
    CYCLES(PARENT, cur, "FIRM")                 
    {
        if (VS(cur, "F_id") != v[5])            // exclude THIS firm
        {
            CYCLES(cur, cur1, "PRODUCT")        // loop over rival products
            {
                v[8] = VS(cur1, "P_id");        // candidate product id
                v[9] = VS(cur1, "P_Profit_Rate"); 

                // check: not already produced & above sector avg
                cur2 = SEARCH_CNDS(THIS, "P_id", v[8]);
                if (cur2 == NULL && v[9] > v[6])
                {
                    v[7] = v[7] + v[9];               // accumulate profitability weight
                }
            }
        }
    }

    if (v[7] > 0)                               // at least one candidate exists
    {
        // 2nd cycle: imitation probability is proportional to profitability
        v[10] = RND * v[7];                     // random draw in [0, total weight]
        v[11] = 0;                              // cumulative sum
        cur3 = NULL;                            // initialize chosen product
        CYCLES(PARENT, cur, "FIRM")
        {
            if (VS(cur, "F_id") != v[5]) 
            {
                CYCLES(cur, cur1, "PRODUCT")
                {
                    v[8] = VS(cur1, "P_id");
                    v[9] = VS(cur1, "P_Profit_Rate");
                    cur2 = SEARCH_CNDS(THIS, "P_id", v[8]);

                    if (cur2 == NULL && v[9] > v[6]) 
                    {
                        v[11] = v[11] + v[9];              // add weight
                        
                        if (cur3 == NULL && v[11] >= v[10])
                            cur3 = cur1;                   // select this product
                    }
                }
            }
        }

        if (cur3 != NULL)                       // a product was selected
        {
            v[12] = VS(cur3, "P_id");               // id of the chosen product
            cur4 = SEARCH_CNDS(PARENT, "M_id", v[12]);  
            v[13] = VS(cur4, "M_date_birth");         

            if (t > v[13] + v[3])               // respect patent protection
            {
                
                PLOG("\nFirm %f", v[5]);
        		PLOG("diversifies and starts producing product %f", v[12]);
        		PLOG("at time %f", T);
                
                cur5 = ADDOBJ_EX("PRODUCT", cur3);     // clone product to THIS firm
                WRITES(cur5, "P_id", v[12]);
                WRITELLS(cur5, "P_Market_Share", 0, t, 1);  
				WRITELLS(cur5, "P_Effective_Orders", 0, t, 1);  

                v[14] = v[12];                  // report id of new product
            }
            else
                v[14] = 0;                       // patent block
        }
        else
            v[14] = 0;                           // no product selected
    }
    else
        v[14] = 0;                               // no eligible candidates
}
else
    v[14] = 0;                                   // imitation failed

RESULT(v[14])


////////////////// INVESTMENT AND FINANCE ///////////////////////


EQUATION("F_Productive_Capacity_Depreciation")
/*
Sum of productive capacity scrapped at t (depreciated capital).
Deletes capital units reaching end-of-life, keeping at least 1 "shell" if only one remains.
*/
v[0] = 0;                                    // capacity scrapped this period
v[1] = COUNT("CAPITAL");
CYCLE_SAFE(cur1, "CAPITAL")
{
    v[3] = VS(cur1, "C_productive_capacity");
    v[5] = VS(cur1, "C_depreciation_period");

    if ((double)t >= v[5] && v[1] > 1)
    {
        v[0] = v[0] + v[3];                  // add scrapped capacity
        DELETE(cur1);                        // remove unit
        v[1] = v[1] - 1;                     // track remaining units
    }
    else
    {
        if ((double)t >= v[5] && v[1] <= 1)
        {
            // keep a shell unit but zero its contribution
            WRITES(cur1, "C_productive_capacity", 0);
            WRITES(cur1, "C_productivity", 0);
        }
    }
}
RESULT(v[0])


EQUATION("F_Productive_Capacity")
/*
Build current productive capacity from existing capital and this-period additions/replacements.
- Expansion: use integer rounding n = (int)(demand + 0.5)
- Replacement: flagged units (C_to_replace == 1) get refreshed to frontier productivity
*/
v[1]  = VL("F_Frontier_Productivity", 1);
v[2]  = VL("F_Demand_Capital_Goods_Expansion", 1);      // real (units); we round below
v[3]  = VL("F_Demand_Capital_Goods_Replacement", 1);    // used only to trigger flags upstream
v[4]  = v[2] + v[3];                                     // not used below (kept for clarity)
v[5]  = V("S_capital_output_ratio");
v[6]  = COUNT("CAPITAL");
v[8]  = V("S_depreciation_period");

// --- expansion: round to integer and add that many units
v[16] = (int)( v[2] + 0.5 );                             // integer #units to add
if (v[16] > 0)
{
    for (i = 0; i < v[16]; i++)
    {
        cur = ADDOBJ("CAPITAL");
        WRITES(cur, "C_productivity",         v[1]);
        WRITES(cur, "C_productive_capacity",  (1 / v[5]));
        WRITES(cur, "C_date_birth",           t);
        WRITES(cur, "C_to_replace",           0);
        WRITES(cur, "C_depreciation_period",  (t + v[8]));
    }
}

// --- replacement: apply only to flagged units
if (v[3] > 0)
{
    SORT("CAPITAL", "C_productivity", "UP");
    CYCLE(cur, "CAPITAL")
    {
        v[9] = VS(cur, "C_to_replace");
        if (v[9] == 1)
        {
            WRITES(cur, "C_productivity",        v[1]);
            WRITES(cur, "C_date_birth",          t);
            WRITES(cur, "C_to_replace",          0);
            WRITES(cur, "C_depreciation_period", (t + v[8]));
        }
    }
}

// --- compute total capacity
if (v[6] != 0)
    v[15] = SUM("C_productive_capacity");
else
    v[15] = 0;

RESULT(v[15])


EQUATION("F_Capital")
	v[0]=COUNT("CAPITAL");                       								
	v[1]=V("S_Capital_Price");                       						
	v[2]=v[0]*v[1];                                 							
RESULT(v[2])


EQUATION("F_Expected_Sales")
	v[0] = SUM("P_Expected_Sales");
RESULT(v[0])

EQUATION("F_Revenue")
v[0]= SUM("P_Revenue");
RESULT(v[0])

EQUATION("F_Desired_Expansion_Investment_Expenses")

   		v[0]=V("F_Expected_Sales");																								 	
   		v[1]=V("F_Productive_Capacity"); 						
		
		v[10]=0;													
		v[11]=V("S_depreciation_period");								
		
		CYCLE(cur, "CAPITAL")										
		{
			v[15]=VS(cur, "C_depreciation_period");
			v[13]=VS(cur, "C_date_birth");				
			v[14]=VS(cur, "C_productive_capacity");		
			if((double)t!=v[13] && ((double)t+1) > v[15])	
				v[10]=v[10]+v[14];									
			else													
				v[10]=v[10];										
		}
																										
   		v[3]=V("F_desired_degree_capacity_utilization");
		v[4]=((v[0])/v[3]) - (v[1]-v[10]);							
   		v[5]=max(0,v[4]);											
   		
		v[6]=V("S_Capital_Price");								
		v[7]=V("S_capital_output_ratio");								
   		v[8]=v[5]*v[6]*v[7];									
   		
RESULT(v[8])


EQUATION("F_Desired_Replacement_Investment_Expenses")
/*
Replacement CAPEX: flag economically-justified replacements and value them.
*/
v[8]  = V("F_Frontier_Productivity");
v[9]  = V("S_depreciation_period");
v[10] = V("F_Wage");
v[11] = V("S_Capital_Price");
v[12] = V("S_capital_output_ratio");
v[13] = V("S_payback_period");

v[16] = 0;
CYCLE(cur, "CAPITAL")
{
    v[19] = VS(cur, "C_depreciation_period");
    if ( (double)t != v[19] && (double)t < v[19] )
    {
        v[17] = VS(cur, "C_productivity");
        v[18] = VS(cur, "C_productive_capacity");
        v[23] = v[11] / ( v[10] * ( (1 / v[17]) - (1 / v[8]) ) );

        if ( v[8] > v[17] && v[23] <= v[13] * v[9] )
        {
            v[16] = v[16] + v[18];
            WRITES(cur, "C_to_replace", 1);
        }
        else
        {
            WRITES(cur, "C_to_replace", 0);
        }
    }
    else
    {
        WRITES(cur, "C_to_replace", 0);
    }
}

v[17] = v[16] * v[11] * v[12];

RESULT(v[17])


EQUATION("F_Investment_Expenses")
v[0]=V("F_Desired_Expansion_Investment_Expenses");
v[1]=V("F_Desired_Replacement_Investment_Expenses");
v[2]=v[0]+v[1];

RESULT(v[2])

EQUATION("F_Demand_Capital_Goods_Expansion")
/*
Number (real) of capital goods demanded for expansion.
*/
v[2] = V("F_Desired_Expansion_Investment_Expenses");
v[3] = V("S_Capital_Price");
v[4] = v[2] / v[3];
RESULT(v[4])


EQUATION("F_Demand_Capital_Goods_Replacement")
/*
Number (real) of capital goods demanded for replacement.
*/
v[2] = V("F_Desired_Replacement_Investment_Expenses");
v[3] = V("S_Capital_Price");
v[4] = v[2] / v[3];

RESULT(v[4])

EQUATION("F_Available_Funds")
/*
Liquid resources BEFORE obligations at t:
= deposits_{t-1} + deposit_interest_{t} + retained_profits_{t}
*/
v[0] = VL("F_Stock_Deposits", 1);       // deposits_{t-1}
v[1] = VL("F_Retained_Profits", 1);         // retained profits at t 
v[5] = V("F_deposit_interest_rate");
v[7] = v[0] * v[5];                     // deposit interest paid at t
v[11] = v[0] + v[7] + v[1];

RESULT(v[11])


EQUATION("F_Stock_Debt")
/*
Debt stock at t.
Financing rule:
- Cash-in before obligations: deposits_{t-1} + deposit_interest + retained_profits.
- Uses at t: Investment + Debt_Payment + Interest_on_Debt.
- If uses > cash-in => borrow the gap; deposits end at 0.
- Else => no new borrowing; leftover increases deposits.
- Debt principal never negative.
*/
v[0]  = VL("F_Stock_Debt", 1);             
v[1]  = V("F_Debt_Payment");                
v[2]  = V("F_Retained_Profits");            
v[3]  = V("F_Investment_Expenses");    
v[4]  = VL("F_Stock_Deposits", 1);          
v[5]  = V("F_deposit_interest_rate");
v[6]  = V("F_debt_interest_rate");          
v[7]  = v[4] * v[5];                       
v[8]  = V("F_Interest_Payment");            // interest on debt at t 

// cash-in and uses
v[9]  = v[4] + v[7] + v[2];                 // cash-in before obligations
v[10] = v[3] + v[1] + v[8];                 // uses: investment + principal + interest

v[11] = v[10] - v[9];                       // net_need (>0 => borrow; <0 => surplus)

// update debt & deposits
if (v[11] > 0)
{
    v[12] = max(0, v[0] - v[1] + v[11]);    // borrow the gap
    WRITE("F_Stock_Deposits", 0);           // deposits fully used
}
else
{
    v[12] = max(0, v[0] - v[1]);            // no new borrowing
    WRITE("F_Stock_Deposits", v[9] - v[10]);// surplus goes to deposits
}

RESULT(v[12])


EQUATION_DUMMY("F_Stock_Deposits", "F_Stock_Debt")


EQUATION("F_Debt_Rate")

v[0] = VL("F_Stock_Debt", 1);
v[1] = VL("F_Capital", 1);
if (v[1] > 0)
    v[2] = v[0] / v[1];
else
    v[2] = 0;
RESULT(v[2])


////////////////// MARKET VARIABLES ///////////////////////



EQUATION("S_Avg_Profit_Rate")
/*
Sector-level average product profit rate.
Computed as the production-weighted average of product-level profit rates.
*/

v[0] = 0;        // sum of profit_rate * production
v[1] = 0;        // sum of production (weights)
CYCLE(cur, "FIRM")
{
    CYCLES(cur, cur1, "PRODUCT")
    {
        v[2] = VS(cur1, "P_Profit_Rate");            // product profit rate
        v[3] = VS(cur1, "P_Effective_Production");  // product effective production (weight)

        // safety: treat negative production as zero
        if (v[3] < 0) v[3] = 0;

        v[0] = v[0] + v[2] * v[3];   // accumulate weighted profit
        v[1] = v[1] + v[3];          // accumulate total production
    }
}

if (v[1] > 0)
    v[4] = v[0] / v[1];
else
    v[4] = 0;

RESULT(v[4])


EQUATION("M_Avg_Price")
/*
Market Avg Price. Avergare of each firm price weighted by the market share.
*/
v[0]=V("M_id");
v[1]=0;
CYCLES(PARENT, cur, "FIRM")
     {
     CYCLES(cur, cur1, "PRODUCT")
     	{
     	v[6]=VS(cur1, "P_Price");	
     	v[7]=VS(cur1, "P_Market_Share");
     	v[8]=VS(cur1, "P_id");
     	if(v[8]==v[0])
     		v[1] = v[1] + v[6]*v[7];
     	else
     		v[1] = v[1];
     	}
     }	
RESULT(v[1])


EQUATION("M_Avg_Competitiveness")
/*
Market Avg Competitiveness. Average of each firm competitiveness weighted by the market share.
*/
v[0]=V("M_id");
v[1]=0;
v[2]=0;
CYCLES(PARENT, cur, "FIRM")
     {
     CYCLES(cur, cur1, "PRODUCT")
     	{
     	v[6]=VLS(cur1, "P_Competitiveness", 1);	
     	v[7]=VLS(cur1, "P_Market_Share", 1);
     	v[8]=VS(cur1, "P_id");
     	if(v[8]==v[0])
     		{
     		v[1] = v[1] + v[6]*v[7];
     		v[2] = v[2] + v[7];
     		}
     	}
     }	
     
     if (v[2] > 0)
     v[3] = v[1]/v[2];
     else
     v[3]=CURRENT;
     
RESULT(v[3])

EQUATION("M_Avg_Market_Share")
/*
Avg Market Share. One divided by the number of firms within this market.
*/
v[0]=V("M_id");
v[1]=0;
CYCLES(PARENT, cur, "FIRM")
     {
     CYCLES(cur, cur1, "PRODUCT")
     	{
     	v[2]=VS(cur1, "P_id");
     	if(v[2]==v[0])
     		v[1] = v[1] + 1;
     	}
     }
		
		if (v[1] > 0)
		v[3] = 1 / v[1];
		else
		v[3] = 0;

RESULT(v[3])

EQUATION("M_Sales")
/*
Total Market Sales. Sum of all firms sales.
*/
v[0]=V("M_id");
v[1]=0;
CYCLES(PARENT, cur, "FIRM")
     {
     CYCLES(cur, cur1, "PRODUCT")
     	{
     	v[6]=VS(cur1, "P_Sales");	
     	v[8]=VS(cur1, "P_id");
     	if(v[8]==v[0])
     		v[1] = v[1] + v[6];
     	}
     }
     
RESULT(v[1])

EQUATION("M_Avg_Sales")
/*
Market average sales.
Production-weighted average of product sales in market M_id.
*/
v[0] = V("M_id");
v[1] = 0;
v[2] = 0;
CYCLES(PARENT, cur, "FIRM")
{
    CYCLES(cur, cur1, "PRODUCT")
    {
        v[6] = VS(cur1, "P_Sales");
        v[7] = VS(cur1, "P_Market_Share");    
        v[8] = VS(cur1, "P_id");
        if(v[8] == v[0])
        {
            v[1] = v[1] + v[6] * v[7];
            v[2] = v[2] + v[7];
        }
    }
}

if (v[2] > 0)
v[3] = v[1] / v[2];
else
v[3] = 0;

RESULT(v[3])

EQUATION("S_Employment")
/*
Sector employment.
Employment = production / productivity.
*/
v[0] = 0;                                        		
CYCLE(cur, "FIRM")                            		
{
    v[1] = VS(cur, "F_Effective_Production");     
    v[2] = VS(cur, "F_Avg_Productivity");   		
    if(v[2] > 0)
        v[0] = v[0] + v[1] / v[2];
}

RESULT(v[0])

EQUATION("M_Market_Avg_Productive_Capacity")
/*
Average productive capacity of firms active in this market.
Each firms productive capacity is weighted by its products market share in M_id.
*/
v[0] = V("M_id");
v[1] = 0;
v[2] = 0;
CYCLES(PARENT, cur, "FIRM")
{
    v[3] = VS(cur, "F_Productive_Capacity");
    CYCLES(cur, cur1, "PRODUCT")
    {
        v[4] = VS(cur1, "P_id");              
        v[5] = VS(cur1, "P_Market_Share");    
        if (v[4] == v[0])
        {
            v[1] = v[1] + v[3] * v[5]; 
            v[2] = v[2] + v[5];
        }
    }
}
if (v[2] > 0)
v[6] = v[1] / v[2];
else
v[6] = 0;

RESULT(v[6])

EQUATION("S_Avg_Debt_Rate")

	v[0] = AVEL("F_Debt_Rate",1);

RESULT(v[0])

EQUATION("M_Market_Share_Adjustment")
/*
Normalize product shares in market M_id to sum to 1.
Called after entry/exit/innovation/imitation events.
*/
V("F_Innovation_Product");
V("F_Imitation_Product");
V("S_Firm_Exit");
V("M_Firm_Market_Exit");
V("S_Market_Exit");
V("M_Firm_Entry");

v[0] = V("M_id");
v[1] = 0;
CYCLES(PARENT, cur, "FIRM")
{
    CYCLES(cur, cur1, "PRODUCT")
    {
        v[2] = VS(cur1,"P_id");
        v[3] = VS(cur1,"P_Market_Share");
        if (v[2] == v[0])
            v[1] = v[1] + v[3];
    }
}
if (v[1] != 1)
{
    v[4] = 0;
    CYCLES(PARENT, cur2, "FIRM")
    {
        CYCLES(cur2, cur3,"PRODUCT")
        {
            v[5] = VS(cur3,"P_id");
            v[6] = VS(cur3,"P_Market_Share");
            if (v[5] == v[0])    
            {
                if (abs(v[1] - 1) > 0.001)
                {  
    			v[8] = (v[1] > 0 ? min(1, v[6]/v[1]) : 0);
				}
                WRITES(cur3,"P_Market_Share", v[8]);
                v[4] = v[4] + v[8];
            }
        }
    }
    v[1] = v[4];
}
RESULT(v[1])

/////////////////ENTRY AND EXIT/////////////////////////////////////


EQUATION("M_Number_Potential_Entrants")
/*
Number of potential entrants.
Computed from demand gap divided by average firm capacity in this market.
*/
V("F_Imitation_Product");

v[0] = V("M_switch_entry");
v[1] = V("M_Effective_Orders");
v[2] = V("S_demand_scale");
v[3] = V("M_Market_Avg_Productive_Capacity");
v[4] = V("M_max_entry_number");

if (v[0] == 0 || v[3] <= exp(-6))
    v[5] = 0;
else
{
    v[6] = (v[2] - v[1]) / v[3];
    v[7] = ceil(v[6]);
    if (v[7] > 0)
        v[5] = min(v[4], v[7]);
    else
        v[5] = 0;
}

RESULT(v[5])



EQUATION("M_Firm_Entry")
/* 
Firm entry process into each market.
New firms are created using as template the firm with average market share (or a fallback).
*/
V("S_Market_Exit");

v[0] = V("M_id");
v[1] = V("M_Number_Potential_Entrants"); 
v[2] = 0;  							// actual entrants

//  Step 1: entry probability 
for (i = 1; i <= v[1]; i++)
{
	v[3] = V("M_Effective_Orders");
	v[4] = VL("M_Effective_Orders", 1);

	if (v[4] > 0)
		v[5] = abs((v[3] - v[4]) / v[4]);
	else
		v[5] = 1;

	v[6] = min(max(0.1, v[5]), 1);
	v[7] = V("M_entry_barrier");
	v[8] = v[6] * v[7];

	if (RND < v[8] && v[3] > v[4])
		v[2] = v[2] + 1;
}

//  Step 2: find representative firm
v[9]  = MAXS(PARENT, "F_id");
v[10] = VL("M_Avg_Market_Share", 1);
v[11] = VL("M_Avg_Price", 1);
v[12] = VL("M_Avg_Sales", 1);
v[13] = VL("M_Avg_Competitiveness", 1);

v[14] = 1;
v[15] = 0;
v[16] = 0;
CYCLES(PARENT, cur1, "FIRM")
{
	v[17] = VS(cur1, "F_id");
	CYCLES(cur1, cur2, "PRODUCT")
	{
		v[18] = VS(cur2, "P_id");
		if (v[18] == v[0])
		{
			v[19] = VS(cur2, "P_Market_Share");
			v[20] = abs(v[19] - v[10]);

			if (v[20] < v[14])
			{
				v[14] = v[20];
				v[15] = v[17];
				v[16] = VS(cur2, "P_desired_inventories_proportion");
			}
		}
	}
}

cur3 = (v[15] > 0) ? SEARCH_CNDS(PARENT, "F_id", v[15]): RNDDRAW_FAIRS(PARENT, "FIRM");

cur4 = (cur3 != NULL) ? SEARCH_CNDS(cur3, "P_id", v[0]) : NULL;
if (cur4 == NULL)
	cur4 = SEARCH_CNDS(PARENT, "P_id", v[0]);
if (cur4 == NULL)
	END_EQUATION(v[2]);

//  Step 3: compute scale and capital 
v[21] = V("M_Effective_Orders");
v[22] = VS(cur3, "F_desired_degree_capacity_utilization");
v[23] = V("S_capital_output_ratio");
v[24] = V("S_depreciation_period");
v[25] = VLS(cur3, "F_Frontier_Productivity", 1);
v[26] = VLS(cur4, "P_Market_Share", 1);

v[27] = ((v[21] * v[26]) * (1 + v[16])) / v[22];  
v[28] = v[27] * v[23];   
v[29] = max(1, (int)floor(v[28] + 0.5));

//  Step 4: create new firms 
for (i = 1; i <= v[2]; i++)
{
	cur5 = ADDOBJ_EXS(PARENT, "FIRM", cur3);

	WRITES(cur5, "F_id", v[9] + i);
	WRITES(cur5, "F_date_birth", t);

	WRITELLS(cur5, "F_Demand_Capital_Goods_Expansion", 0, t-1, 1);
	WRITELLS(cur5, "F_Demand_Capital_Goods_Replacement", 0, t-1, 1);
	WRITELLS(cur5, "F_Stock_Debt", 0, t-1, 1);
	WRITELLS(cur5, "F_Stock_Deposits", 0, t-1, 1);
	WRITELLS(cur5, "F_Frontier_Productivity", v[25], t-1, 1);

	v[30] = 0;
	CYCLE_SAFES(cur5, cur6, "PRODUCT")
	{
		v[31] = VS(cur6, "P_id");
		if ((v[31] == v[0] && v[30] == 0) || (v[30] == 0 && COUNTS(cur5, "PRODUCT") == 1))
		{
			v[30] = 1;
			WRITES(cur6, "P_id", v[0]);
			WRITES(cur6, "P_Price", v[11]);

			WRITELLS(cur6, "P_Market_Share", v[26], t-1, 1);
			WRITELLS(cur6, "P_Avg_Market_Share", v[26], t-1, 1);
			WRITELLS(cur6, "P_Competitiveness", v[13], t-1, 1);
			WRITELLS(cur6, "P_Desired_Market_Share", v[26], t-1, 1);
			WRITELLS(cur6, "P_Effective_Orders", v[21] * v[26], t-1, 1);
			WRITELLS(cur6, "P_Expected_Sales", v[12], t-1, 1);
			WRITELLS(cur6, "P_Inventories", v[21] * v[26] * v[16], t-1, 1);
			WRITELLS(cur6, "P_Profit_Rate", 0, t-1, 1);
			WRITELLS(cur6, "P_Innovation_RND_Share", 0.5, t-1, 1);
		}
		else
			DELETE(cur6);
	}

	v[32] = COUNTS(cur5, "CAPITAL");
	CYCLE_SAFES(cur5, cur7, "CAPITAL")
	{
		if (v[32] > 1)
		{ DELETE(cur7); v[32]--; }
	}

	ADDNOBJS(cur5, "CAPITAL", v[29] - 1);
	CYCLES(cur5, cur8, "CAPITAL")
	{
		WRITES(cur8, "C_productivity", v[25]);
		WRITES(cur8, "C_productive_capacity", (1.0 / v[23]));
		WRITES(cur8, "C_date_birth", t);
		WRITES(cur8, "C_to_replace", 0);
		WRITES(cur8, "C_depreciation_period", (t + v[24]));
	}

	PLOG("\nFirm %f", v[9] + i);
	PLOG("enters market %f", v[0]);
	PLOG("at time %f", T);
}

RESULT(v[2])



EQUATION("S_Firm_Exit")
/*
Firm exit by excessive leverage.
Deletes firms with debt-to-capital ratio > max leverage.
Ensures at least one firm survives.
*/
v[0] = V("S_switch_exit");
v[1] = 0;

CYCLE_SAFE(cur1, "FIRM")
{
	v[2] = COUNT("FIRM");
	v[3] = VS(cur1, "F_Stock_Debt");
	v[4] = VS(cur1, "F_Capital");

	if (v[0] != 0 && v[2] > 1)
	{
		if (v[4] <= 1e-6 || (v[3] / v[4]) > V("S_max_leverage_ratio"))
		{
			PLOG("\nFirm %f", VS(cur1, "F_id"));
			PLOG("deleted for excessive leverage at period %f", T);
			DELETE(cur1);
			v[1]++;
		}
	}
}

RESULT(v[1])



EQUATION("M_Firm_Market_Exit")
/*
Firm exit out of each market (product-level exit).
Deletes products with very low market share, and if firm only had that product, deletes firm.
*/
v[0] = V("S_switch_exit");
v[1] = 0;
v[2] = VS(PARENT, "S_min_market_share");

CYCLE_SAFE(cur1, "FIRM")
{
	v[3] = COUNTS(PARENT, "FIRM");
	CYCLE_SAFES(cur1, cur2, "PRODUCT")
	{
		v[4] = VS(cur2, "P_Market_Share");
		v[5] = COUNTS(cur1, "PRODUCT");

		if (v[0] != 0 && v[4] <= v[2])
		{
			if (v[5] > 1)
			{
				PLOG("\nFirm %f", VS(cur1, "F_id"));
				PLOG("stopped producing product %f", VS(cur2, "P_id"));
				PLOG("at period %f", T);
				DELETE(cur2);
			}
			else if (v[3] > 1)
			{
				PLOG("\nFirm %f", VS(cur1, "F_id"));
				PLOG("deleted (only low-share product) at period %f", T);
				DELETE(cur1);
				v[1]++;
			}
		}
	}
}

RESULT(v[1])



EQUATION("S_Market_Exit")
/*
Deletes a market if no firm produces its product.
Ensures at least one market remains.
*/
V("S_Firm_Exit");
V("M_Firm_Market_Exit");

v[0] = 0;

CYCLE_SAFE(cur1, "MARKET")
{
	v[1] = COUNT("MARKET");
	v[2] = VS(cur1, "M_id");
	v[3] = 0;

	CYCLE(cur2, "FIRM")
	{
		CYCLES(cur2, cur3, "PRODUCT")
			if (VS(cur3, "P_id") == v[2])
				v[3]++;
	}

	if (v[3] == 0 && v[1] > 1)
	{
		PLOG("\nMarket %f", v[2]);
		PLOG("deleted at period %f", T);
		DELETE(cur1);
		v[0]++;
	}
	else if (v[3] == 0 && v[1] <= 1)
	{
		PLOG("\nMarket %f", v[2]);
		PLOG("should be deleted but preserved as last at period %f", v[2], T);
	}
}

RESULT(v[0])




////////////////// ANALYTICAL VARIABLES ///////////////////////


EQUATION("M_Market_Firm_Number")
/*

*/
v[0] = V("M_id");                   
v[1] = 0;                       // counter of firms active in this market

CYCLES(PARENT, cur, "FIRM")  
{
    v[2] = 0;                     // temporary flag to check if firm participates in this market
    CYCLES(cur, cur1, "PRODUCT")  
    {  
        v[3] = VS(cur1, "P_id");            
             
        if (v[3] == v[0])          // match product with current market
        {
            v[2] = 1;             // mark firm as active in this market
        }
    }
    if (v[2] == 1)  
        v[1] = v[1] + 1;       // count this firm
}

RESULT(v[1])


EQUATION("M_Market_Normalized_HHI")
/*
Normalized Herfindahl-Hirschman Index (HHI) for a single market.
*/
V("S_Market_Exit");
V("M_Firm_Market_Exit");
V("S_Firm_Exit");
V("M_Firm_Entry");

v[0] = V("M_id");                            
v[1] = 0;                                    // sum of squared market shares
v[2] = V("M_Market_Firm_Number");            // number of firms active in this market

CYCLES(PARENT, cur, "FIRM")
{
    CYCLES(cur, cur1, "PRODUCT")
    {
        v[3] = VS(cur1, "P_id");

        if (v[3] == v[0])                    // is product associated with this market?
        {
            v[4] = VS(cur1, "P_Market_Share");
            v[1] = v[1] + v[4] * v[4];       // sum of squared market shares
        }
    }
}

if (v[2] > 1)
    v[5] = max(0, min(1, (v[1] - (1/v[2])) / (1 - (1/v[2]))));  // normalized HHI
else
    v[5] = 1;                               // monopoly

RESULT(v[5])


EQUATION("S_Firm_Number")
RESULT(COUNT("FIRM"))


EQUATION("S_Sector_Normalized_HHI")
/*
Sector-level normalized Herfindahl-Hirschman Index (HHI).
Weighted average of each market's normalized HHI, weighted by the number of firms.
*/

v[0]= 0;                        // weighted sum of HHI
v[1]=V("S_Firm_Number");

CYCLE(cur, "MARKET")  
{
    v[2]= VS(cur, "M_Market_Normalized_HHI");   
    v[3]= VS(cur, "M_Market_Firm_Number");        

    if (v[3] > 0)
    {    
        v[0]= v[0] + v[2] * v[3];    // weighted HHI
    }
}

v[4]= (v[1] > 0) ? v[0] / v[1] : 0;  // avoid division by zero

RESULT(v[4])




MODELEND

// do not add Equations in this area

void close_sim( void )
{
	// close simulation special commands go here
}

END_EQ_FILE
